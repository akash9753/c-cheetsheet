DbContext - for interacting with database, all the logic that is needed for entitiy framwork core like access a database, retrive, update 
            delete create table, all this logic provide by DbContext class

DbSet - classes we want in our application and create it in the database

in class BookID or Id or [Key]

Command :-
update-database
add-migration decimal
Remove-Migration
get-migration
drop-database

Rollback to old migration
update-database AddBookToDb

Data Annotation :-
[Table("tb_geners")]
[Column("Name")]
[Key]
[Required]

Relation in efcore
1.one to one - onDelete: ReferentialAction.Cascade); (if book deleted then bookdetails also be deleted)
2.one to many - 1 publisher have many book. but 1 book has only one publisher
3.many to many - Book and Authors



First - always expect atleat one element else return exception
FirstOrDefault - if no records are found it return null. if found multiple element return first one

Find - only filter directly for key

Single - single expects only one element. if found multiple element return throws an exception
SingleOrDefault - it will return null if no records are found, Throws Exception if more than one element matches.

Pagination - Skip(0), Take(2);
------------------------------------------------------------
Concurrency in EF Core (2 Main Ways) - when multiple users or processes can update the same data at the same time, and data integrity must be preserved.

1. Optimistic Concurrency (default & recommended)
    a. Use [Timestamp] or .IsConcurrencyToken() on a property.
    b. EF throws DbUpdateConcurrencyException when a conflict is detected.
    c.Requires handling conflict manually in code.

    [Timestamp]
    public byte[] RowVersion { get; set; } 

2. Pessimistic Concurrency (manual)
   a. Use database-level row locking with raw SQL and WITH (UPDLOCK).
   b. Requires transactions.
   var employee = context.Employees
    .FromSqlRaw("SELECT * FROM Employees WITH (UPDLOCK) WHERE Id = 1")
    .FirstOrDefault();
-------------------------------------------------------
Parallelism in EF Core (1 Safe Way + 1 Unsafe)

1. Safe: Parallel DB Queries in Separate DbContext Instances
   a. EF Core's DbContext is not thread-safe.
   b. Use separate instances of DbContext for parallel operations.
   var task1 = Task.Run(() => UseDbContext1());
   var task2 = Task.Run(() => UseDbContext2());
   await Task.WhenAll(task1, task2);

2. Unsafe: Sharing the Same DbContext Across Threads (‚ùå Not Recommended)
   a. Leads to data corruption, exceptions, or deadlocks.
   b. Always avoid multi-threading on the same DbContext.
































